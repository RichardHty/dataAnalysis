#cheat sheet

#quantitative data
quantile(data$variable)
#qualitative data
#class frequencies
table(data$variable)

#histogram

#change data type into a vector
data<-unlist(duration, use.names=FALSE)
#make sure the range is just right
range_days <- max(data) - min(data) + 1
#generate a density histgram
hist(data,range_days,labels = TRUE,prob=TRUE,
     main = "Distribution of Duration of Days", 
     xlab = "duration")
lines(density(data),col="red")

#generate a boxplot 
boxplot(data)

#normal distribution
z=1.2
c = 0.8849303
a = 0
b = 1
#area to the left of z
z<-pnorm(z)
z_score<-pnorm(z,mean=a,sd=b)
#z-score with a as the area to the left
p<-qnorm(c)
probability<-qnorm(c,mean=a,sd=b)
#get the point value of normal distribution
d<-dnorm(x)

#outlier
boxplot()
#from t-statistic calculate prob
p<-pt(t_statistic,df=degreeOfFreedom)
#from prob calculate t-statistic
t<-qt(prob,df=degreeOfFreedom)

#t.test
#alternative can be ‘less’, ‘greater’, or ‘two.sided’
t.test(data$variable, mu=mu0, alternative='two.sided', conf.level=0.9)
shark_len<- c(18.1, 23.4, 23.8, 24.1, 22.5, 19, 25.4, 23.1, 16.5, 26.7)
t <- (mean(shark_len) - 20)/(sd(shark_len)/sqrt(length(shark_len))) 
p <- 1 - pt(t , df=length(shark_len) - 1)
t.test(shark_len, mu=20, alternctive="two sided", conf.level=0.9)

#correlation
r<-cor(data)
#t-test for linear association, nature is t-test so can be calculated through qt(prob,df)
t_association<-r*(sqrt((n-2)/(1-r*r)))
# or [alternative] = ‘two.sided’, ‘less’ (corresponds to negative association), or ‘greater’ (corresponds to positive association)
#[method] = “pearson”, “kendall”, or “spearman”
cor.test(data$explanatoryvariable, data$responsevariable,
         alternative='alternative', method='method', conf.level='confdence level')

#simple linear regression
slr<-lm(data$response~data$explanatory) 
abline(a=intercept, b=slope)
# r square
anova()
# Calculating probability from F-statistics
pf('F statistic', df1='degree of freedom of the numerator', df2='degree of freedom of the denominator')
#Calculating F-statistics from probability
qf('probability', df1='degree of freedom of the numerator', df2='degree of freedom of the denominator')
#t-test for linear regression
summary(slr)
t<-beta1/se_beta1
confint(slr,level=0.95)

#multiple variables correlation
salary1 <- salary/1000
data1 <- data.frame(age, height, salary1)
cor(data1)
pairs(data1)
#MLR
m <- lm(salary1~age+height)
summary(m)
#residual plot
resid(m)
par(mfrow=c(2,2))
plot(fitted(m), resid(m), axes=TRUE, frame.plot=TRUE, xlab='fitted values', ylab='residue')
plot(age, resid(m), axes=TRUE, frame.plot=TRUE, xlab='age', ylab='residue')
plot(height, resid(m), axes=TRUE, frame.plot=TRUE, xlab='height', ylab='residue') > hist(resid(m))

#anova
#make factor:
data <-c(1,2,2,3,1,2,3,3,1,2,3,3,1)
fdata <-factor(data)
is.factor(data$smoker)

#aov:
m <- aov(data$response~data$group) # $group must be a factor
#or lm
#Create dummy variables and use lm to do one-way anova
data$g0 <- ifelse(data$group=='currentHeavySmoker', 1, 0)
data$g1 <- ifelse(data$group=='currentLightSmoker', 1, 0)
data$g2 <- ifelse(data$group=='formerSmoker', 1, 0)
data$g3 <- ifelse(data$group=='neverSmoker', 1, 0)
m2<- lm(data$response~data$g0+data$g1...)
anova(m2)
#t-test
pairwise.t.test(data$response, data$group, p.adj='method')
#Note: method = “holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")
TukeyHSD(m, conf.level = 0.95)#m needs to be generated by aov
#ancova
library(car)
Anova(lm(data$response~data$group + data$covariate), type=3)
library(lsmeans)
lsmeans(lm(data$response~data$group+data$covariate), pairwise~data$group, adjust='method')
#Note: method = “tukey”, “schefe”, “sidak", "bonferroni", “dunnettx", “mvt", "none")

#two-way analysis of variance, interaction
#Test interactions
model <- lm(Energy~PreStretch+AnkleWeights+PreStretch*AnkleWeights, data=exercise)
summary(model)
interaction.plot(data$group1, data$group2, data$response, col=1:2)
#If p-value for the interaction is not signifcant, then run regular two-way ANOVA
model<-lm(data$response ~ data$group1+ data$group2)
#If interaction is signifcant, need to stratify (by more of the two factors)
stretch <- exercise[which(PreStretch=='Stretch'),]
nostretch <- exercise[which(PreStretch=='No stretch'),]
summary(aov(Energy~AnkleWeights, data=stretch))
summary(aov(Energy~AnkleWeights, data=nostretch))

#sample test for a proportion
prop.test('[s]',' [n]', p='[p0]', alternative='[alternative]', 
          conf.level='[confdence level]', correct='FALSE||TRUE')
#[s]: number of successes
#[n]: sample size
#for two-sample [s]: number of successes in each group: c(s1, s2) 
#for two-sample [n]: sample size in each group: c(n1, n2 )
#[p0]: population proportion p
#[alternative]: “two.sided” (default), “greater”, “less” [confdence level]: default 0.95
#Correct = FALSE specifes not to use a continuity correction; Default is to apply correction

#logistic regression
m<-glm(data$event~data$explanatory1 + data$explanatory2 + ..., family=binomial)
#OR per 1 unit increase
exp(cbind(OR = coef(m), confnt.default(m)))
#OR per 10 unit increase 
exp(m$coefcients[2]*10)
#confidence interval for 10 units increase
exp((m$coefcients[2]-qnorm(0.975)*summary(m)$coefcients[2,2])*10)
exp((m$coefcients[2]+qnorm(0.975)*summary(m)$coefcients[2,2])*10)
# predicted risk for each patient 
risk <- predict(m, type=c("response"))
#or for patient with cholesterol of 190
exp(m$coefcients[1]+m$coefcients[2]*190)/(1+exp(m$coefcients[1]+m$coefcients[2]*190))

# multiple logistic regression
data$male <- ifelse(data$sex =="M", 1, 0)
m2<-glm(data$event ~ data$chol + data$male + data$age, family=binomial)
summary(m2)
# overall test
# install.package("aod")
library(aod)
wald.test(b=coef(m2), Sigma = vcov(m2), Terms = 2:4)
# Terms: An optional integer vector specifying which coefcients should be jointly tested
# Terms defnes to compare which regression coefcients, here we want to compare the 2 to 4 (frst is the intercept)
# It gives as a result Chi-Squared test results, and p-value of it
# if p is smaller than 0.05 you can reject the null hypothesis
# ORs per 1 unit increase
exp(cbind(OR = coef(m2), confnt.default(m2)))
#ROC curve
library(pROC) # for visualizing, smoothing and comparing receiver operating characteristic (ROC curves).
data$prob <- predict(m, type=c("response")) 
g <- roc(data$event ~ data$prob)
plot(g)
